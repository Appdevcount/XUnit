TDD - Test Driven Development
    Relies on repetition of short development cycle, requirements are turned into specific test cases and then minimal code is written to  pass  and then refactored 

    RED->GREEN->REFACTOR Phases

    Advantages
        Think about class or API needed to implement
        Think about what code must do 
        Feedback on expected Business output in initial phase
        Modular or Decouple dependencies with mocking 
        Maintainable code 
        Documentation

    Disadvantage 
        Adds more to development process 

    Example: Ticket Booking Platform
    1)Frame workflow diagram for requiremnt actions/sets (Book ,Cancel etc..)
    2)Create Test Project and write test case method in [MethodUnderTest]_[Scenario]_[ExpectedResult]/Given__When_Then name format.
        Eg:void Book_WhenAandBParametersArePassed_ReturnSuccesResponse()
           void Book_WhenRequestObIsNull_ThrowsNullException()
           
    3)Write test case for Book method ,Inside it invoke actual class and autogenerate then which accepts Business parameter and return expected response. This is easier to constructuct Request Object with values and autogenerate actual class with properties .Make it pass with minimal code.
    4)Refactor code by moving autogenerated actual files in Test project to actual project ,Change access specifiiers as required and namespace .Add actual project dependency to Test projecr



Xunit

XUnit.net Library(dll) referenced in Test Project
Test Runner referenced

Vsual Studio Test explorer

Create Test Project
===================

dotnet new Xunit
    by default add reference packages
       Microsoft.Net.Test.SDK
       XUnit
       Xunit.runner.visualstudio
       coverlet.collector - code coverage



Attributes/Data Annotation
    [Fact-void method],[Theory(parameters...)]
Assertions :To verify if Test passed or failed
    .Equal,.NotEqual,.Contains,.DoesnotContain,.Empty,Null,NotNull,False,.Matched(),Check Collections,Check Events,Check Objecttype,Verify()... starts with Assert.
    Assert.True(true);

FunctionalityNameOrClassNameTests.cs
    [Fact]
    public void UnderConsition_TestMethod_ReturnsTrue(){
        //Arrange -Creating object andor passing input data
        Actualcls sut=new Actualcls();//system under test
        //Act - performing action on object or mock object
        bool res=sut.isnoob();
        //Assert - verifying result of action with expected Assertion
        Assert.True(res);
    }


dotnet build - compile the test Project

dotnet test or Use the plugin UI to run the Test , will display the status details on running 

Assert for Events -Event driven system 
    Assert.Raises<EventArgs>(
        handler=>sut.property+=handler,//attach
        handler=>sut.property-=handler,//detach
        ()=>sut.sleep()
    );

Assert for property changes Event
    Assert.PropertyChanged(sut,"Health",()=>sut.Changeprop("10"))

Asserting expected subtype returned
    Assert.IsType<NormalUser>(user)
    Assert.IsNotType<OrgUser>(user)    

Asserting replaceable type with base type
    Assert.IsAssignableFRom<enemy>(normalenemy)

Asserting particular exception type
    Assert.Throws<ArgumentNullexception>(()=>sut.create(null))

Trait["TestCategory,"CategoryType"] //Grouping    //This groups test methods or classes
    dotnet test --filter "TestCategory=CategoryType" //execute all related tests in that categrytype key

Adding Custom message to Test 
    ITestOutputHelper - XUnit.Abstraction ... it has writeline("") method for writing some journals

Shared test Context -3 approached
    Constructor and IDisposable.Dispose method //Common dependent object instance in a Testclass property and disposing at the end using Dispose method
    Class Fixtures
        TestClass:Implement IClassFixture<RealClassFixture> , it helps to injects the fixture class in TestClass Constructor... 
        RealClassFixture:IDisposable is the one which has the real class object in a property created and assigned in Constructor
        Its used when we want to use single test context among test methods and clean up after executed
    Collection Fixtures 
        Create a class and implement ICollectionFixture<> interface and decorate the class with Collection Definition attribute 
        User Collection attrubute on the class where you want the fixture to be used
        Its used when we want to shared single test context among test methods in several test classes and cleanup after executed 

Data Driven Testing
    In this approach Input data comes from external source(file,DB), it reduces the number of test methods for different inputs

    Diffirent ways for providing Test Data 
    [Theory]
    [InlineData(1,"a")] Attribute - Locally to a Test and Managed by a Developer
    [Theory]
    [MemberData("StaticPropertyNameOfTestDataClasswhichreturnsIEnnumerable<object[]>",MemberType=typeof(TestDataClass))]--    Property/Field/Method -Shareable and managed by developer 
    Custom Attributes [by inheriting DataAttribute class and overiding its GetData method ]-Shareable and managed by developer 
    External Data [Testdata.txt with comma separated values, use the above GetData method to read from this file] -Shareable and managed by developer or Non Developer 

Mocking
    Mimic or imitate the behaviour of some dependent object - helps in isolated test method

    MOQ- Mocking framework library , opensource
    dotnet add package moq 

    Mock<Interface/Abstraction> mock=new Mock<Interface/Abstraction>();
    //Mock<Interface/Abstraction> mock=new Mock<Interface/Abstraction>(MockBrhaiour.Strict);//will make mock object dependendt object definition must .. ie.. Setup on dependent method is must in this case
    mock.Setup(x=>x.dependentmethod("y")).Returns(true);
    mock.Setup(x=>x.dependentmethod(It.IsAny<string>())).Returns(true);//anyvalueoftype
    mock.Setup(x=>x.dependentmethod(It.Is<string>(n=>n.StartsWith("y")))).Returns(true);//startswithvalue
    mock.Setup(x=>x.dependentmethod(It.IsInRange("a","z",Moq.Range.Inclusive))).Returns(true);//rangevalue
    //For a dependent object method which returns void, we can use .Callback(()=>{localexpectedobj=inputobj;}). and can assert on the callback assignment with expected value
    mock.Setup(x=>x.dependentmethod(It.IsAny<inputobj>())).Callback<inputobj>((inputobj)=>{localexpectedobj=inputobj;});
    mock.Setup(x=>x.dependentProperty).Returns("123");
    mock.Setup(x=>x.dependentProperty).Returns("123");


    Hierarchical depenency scenario or multilevel dependency scenario
    can manage hierarchical dependency manually in this case
    var innermockwithsetup;
    var outermock.setup(x=>x...).Returns(innermockwithsetup);
    or can also mention it by Automapping of property in single line
    var outermock.setup(x=>x.innerdepndentobject.property).Returns("innerobjpropertyvalue");

    we can ensure that a particular dependent method is called in mockobject a sbelow
    mock.Verify(x=>x.dependentmethod("somevalue"|It.IsAny<string>(),"Custom message to display if the depnentmetho call will not be  happended in mockobject"));//similarly Times.Once as 2nd parameter check if the method is called exactly once

    mock.SetupProperty(x=>x.property)//sets/intialize some read only property in the object itself before using the mock object

    mock.VerifyGet(x=>x.validationmode,Times.Once);//This check if the property has value 

    mock.VerifySet(x=>x.validationmode=It.IsAny<ValidationMode>(),Times.Once);//This check if the property is set once once

    var dependentobject=mock.Object;//can be injected anywhere

    sut.Evaluate(dependentobject)

Code Coverage 
    Measurement of amount of lines/branches/methods of unit tested code
    Only VS Enterprise has built in support for code coverage and report in html
    Coverlet as Code coverage package
        dotnet add package coverlet.collector  
        dotnet test --collect="just a name for report from test results,it will generate a xml file in new Testresults folder"
    dotnet-reportgenerator-globaltool tool for view html report from xml.This will create report html in coveragereport folder
        dotnet tool install --global dotnet-reportgenerator-globaltool
        reportgenerator "-reports:xmlreport.xml" "-targetdir:coveragereport" -reporttypes:html
        







    
